package io.sugo.pio.datatable;

import io.sugo.pio.report.Tableable;
import io.sugo.pio.tools.Tools;

import java.io.IOException;
import java.io.PrintWriter;
import java.lang.ref.WeakReference;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;


/**
 * This abstract data table implementation provides some default implementations for data tables
 * like listener handling. The method {@link #fireEvent()} can be used to promote changes to all
 * listeners.
 *
 * In addition, IO methods are also provided by this abstract implementation.
 *
 * @author Ingo Mierswa
 */
public abstract class AbstractDataTable implements DataTable, Tableable {

    /** The list of data table listeners. */
    private List<WeakReference<DataTableListener>> weakReferencedListeners = new LinkedList<>();
    private List<DataTableListener> listeners = new LinkedList<>();

    /** The name of the table. */
    private String name;

    private HashSet<String> deselectionSet = new HashSet<>();

    private int deselectionCount;

    /**
     * This is a constructor that will not set any name. It is used for serialization of subclasses.
     */
    public AbstractDataTable() {
        this("");
    }

    public AbstractDataTable(String name) {
        this.name = name;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String[] getColumnNames() {
        String[] result = new String[getNumberOfColumns()];
        for (int i = 0; i < result.length; i++) {
            result[i] = getColumnName(i);
        }
        return result;
    }

    @Override
    public void addDataTableListener(DataTableListener dataTableListener, boolean weakReference) {
        if (weakReference) {
            this.weakReferencedListeners.add(new WeakReference<>(dataTableListener));
        } else {
            addDataTableListener(dataTableListener);
        }
    }

    @Override
    public void addDataTableListener(DataTableListener dataTableListener) {
        listeners.add(dataTableListener);
    }

    @Override
    public void removeDataTableListener(DataTableListener dataTableListener) {
        Iterator<WeakReference<DataTableListener>> it = weakReferencedListeners.iterator();
        while (it.hasNext()) {
            DataTableListener l = it.next().get();
            if (l == null || l == dataTableListener) {
                it.remove();
            }
        }
        listeners.remove(dataTableListener);
    }

    protected void fireEvent() {
        // copy to avoid ConcurrentModification
        List<WeakReference<DataTableListener>> clone = new LinkedList<>(weakReferencedListeners);
        Iterator<WeakReference<DataTableListener>> i = clone.iterator();
        while (i.hasNext()) {
            WeakReference<DataTableListener> reference = i.next();
            DataTableListener listener = reference.get();
            if (listener != null) {
                listener.dataTableUpdated(this);
            } else {
                weakReferencedListeners.remove(reference);
            }
        }

        for (DataTableListener l : listeners) {
            l.dataTableUpdated(this);
        }
    }

    @Override
    public String getValueAsString(DataTableRow row, int column) {
        final double value = row.getValue(column);
        if (Double.isNaN(value)) {
            return null;
        } else if (isDate(column)) {
            return Tools.formatDate(new Date((long) value));
        } else if (isDateTime(column)) {
            return Tools.formatDateTime(new Date((long) value));
        } else if (isTime(column)) {
            return Tools.formatTime(new Date((long) value));
        } else if (isNominal(column)) {
            return mapIndex(column, (int) value);
        } else {
            return value + "";
        }
    }

    @Override
    public void write(PrintWriter out) throws IOException {
        out.println("# Generated by " + getName() + "[" + getClass().getName() + "]");
        for (int j = 0; j < getNumberOfColumns(); j++) {
            out.print((j != 0 ? "\t" : "# ") + getColumnName(j));
        }
        out.println();

        for (DataTableRow row : this) {
            for (int j = 0; j < getNumberOfColumns(); j++) {
                out.print((j != 0 ? "\t" : "") + getValueAsString(row, j));
            }
            out.println();
        }

        out.flush();
    }

    @Override
    public boolean containsMissingValues() {
        Iterator<DataTableRow> i = iterator();
        while (i.hasNext()) {
            DataTableRow row = i.next();
            for (int j = 0; j < getNumberOfColumns(); j++) {
                if (Double.isNaN(row.getValue(j))) {
                    return true;
                }
            }
        }
        return false;
    }

    @Override
    public int getRowNumber() {
        return getNumberOfRows();
    }

    @Override
    public int getColumnNumber() {
        return getNumberOfColumns();
    }

    @Override
    public String getCell(int row, int column) {
        double value = getRow(row).getValue(column);
        if (isDate(column)) {
            return Tools.formatDate(new Date((long) value));
        } else if (isDateTime(column)) {
            return Tools.formatDateTime(new Date((long) value));
        } else if (isTime(column)) {
            return Tools.formatTime(new Date((long) value));
        } else if (isNominal(column)) {
            return mapIndex(column, (int) value);
        } else {
            return Tools.formatIntegerIfPossible(value);
        }
    }

    @Override
    public void prepareReporting() {}

    @Override
    public void finishReporting() {}

    @Override
    public boolean isFirstLineHeader() {
        return false;
    }

    @Override
    public boolean isFirstColumnHeader() {
        return false;
    }
}
